![MIT 许可协议](https://img.shields.io/badge/license-MIT-blue.svg)
==============

cppcryptfs
------

cppcryptfs 基于 [gocryptfs](https://github.com/rfjakob/gocryptfs) 设计，而 gocryptfs 是用 Go 语言编写的一个叠加式加密文件系统。

cppcryptfs 是使用 C++ 编写的一个面向 Windows 系统实现的 gocryptfs 文件系统。cppcryptfs 与 gocryptfs 兼容。这两种工具创建的文件系统通常可以相互挂载和同步。详见本文档末尾的兼容性声明。

cppcrypts 在一个虚拟文件系统中为文件和文件名提供动态、静态和云存储中加密的能力。它使用 [Dokany](https://github.com/dokan-dev/dokany) 驱动程序和程序库在 Windows 的用户模式下提供该虚拟文件系统。


您可以通过 cppcryptfs 在文件夹中创建一个加密的文件系统。加密的文件系统使用您选择的密码来保护。

当您使用 cppcryptfs 并提供密码来挂载加密的文件系统时，Windows 中会新增一个驱动器号（盘符）。这个虚拟的驱动器号为您提供里面文件的未加密视角。加密和解密会动态完成，并且对使用该虚拟驱动器中的文件的应用程序来说是透明的（无感知）。

在告知 cppcryptfs 卸载该虚拟驱动器号后，除非再使用您的密码来重新挂载该文件系统，否则不能再访问未加密的数据。

关闭计算机时将自动卸载所有 cppcryptfs 驱动器号。

如果保存着已加密文件的文件夹使用了文件云同步服务，只会将加密状态的文件（文件名和文件数据均已加密）上传到云服务。

因此，云存储服务的员工或者侵入的黑客等任何人都无法访问您的文件内容。

此外，如果有人窃取了您的计算机，并且此时没有挂载加密的文件系统，则窃贼也无法访问您的文件。

由于这种加密采用按文件管理，而不是使用容器文件来存储数据，因此您不必提前决定加密存储要占用多少磁盘空间。cppcryptfs 只有非常小的存储开销，并且加密文件系统的空间可以动态增长，只受所在磁盘分区的可用空间限制。

与基于容器的加密相比，按每个文件加密还有一个优点，它可以非常快速且有效地配合云同步存储服务的机制。


当前状态
--------------

开发者使用 cppcryptfs 的正向（正常）模式超过3年，没有丢失任何数据。有至少一个人在使用该项目。

反向模式仅经过开发者的有限测试。

[发布页面](https://github.com/bailey27/cppcryptfs/releases)中提供了由开发人员 Bailey Brown Jr 签名的二进制（可执行）文件。


慎重地保留数据备份始终是明智的，以防出现意外问题。

测试
-------

以管理员权限运行时，cppcryptfs 在 [winfstest](https://github.com/bailey27/winfstest) 中通过了 506/506 项测试。以非管理员权限运行时，cppcryptfs 通过了 500/506 项测试。Dokany 团队增加了额外的测试。

在不使用管理员权限运行时，cppcryptfs 未通过的测试与 DACL（自主访问控制列表）操作有关。cppcryptfs 以管理员权限运行时，才能正常完成这些操作。不使用管理员权限运行的情况下，似乎不会影响到 cppcryptfs 的正常使用。

注意：Windows 10 版本 1909（操作系统内部版本 18363.1016）似乎允许 cppcryptfs 通过完整的 506 项测试，而无需以管理员权限运行。


构建所需环境
-----

    Microsoft Visual Studio 2019 社区版、perl、nasm 和 git（全部免费）
    OpenSSL - https://github.com/openssl/openssl（需要静态构建）
    RapidJSON - https://github.com/miloyip/rapidjson （用于解析 gocryptfs.conf）
    Dokany - https://github.com/dokan-dev/dokany

    对于 Dokany，您也许愿意使用下列位置中分发的二进制版本：
    	https://github.com/dokan-dev/dokany/releases
    注：务必在安装程序选项中选择“安装开发文件”（"install development files"）



[INSTALL.md](INSTALL.md) 文件中有详细的构建步骤说明。

cppcryptfs 目前使用（发布时）最新的 Dokany 2.0.0.2000 版本


使用
-------

cppcryptfs 不需要管理员权限即可运行，但如果它没有管理员权限，将无法获得 SE_SECURITY_NAME 特权。Windows API 函数 SetFileSecurity() 和 GetFileSecurity() 执行某些操作时需要 SE_SECURITY_NAME 特权。

cppcryptfs 似乎能在没有 SE_SECURITY_NAME 的情况下正常运行。但如果您遇到了问题，您可以尝试以管理员权限运行 cppcryptfs，看问题是否解决。

要创建新的加密的虚拟文件系统，先单击“创建”选项卡。

![Alt text](/screenshots/screenshot_create.png?raw=true "创建选项卡")

您需要找到或创建一个目录作为新建的文件系统的根目录。您可以在目录选择器界面中创建一个目录。

如果要使用的是正常（正向）模式，则该目录必须为空。

如果要使用的是反向模式，则该目录不应为空。详见本文档中有关“反向模式”章节。

强烈建议将目录放在 NTFS 文件系统中。

然后，您需要选用一个尽量强的密码并二次输入确认无误。对话框最多允许 255 个字符的密码。

该密码框有个怪癖，它将 U+00D7 字符作为保留字符。此字符看起来像一个小写 x，但不相同。

因此不能在密码中使用该字符。

您可以选择使用 AES256-EME 加密文件名，也可以选择不加密文件名（纯文本，即明文）。

如果选中“长文件名”，则在使用加密文件名时，文件和目录的名称长度最多为 255 个字符。如果使用纯文本文件名，则此选项无效果，但纯文本文件名的长度最多也为 255 个字符。更多细节详见本文档末尾的“文件名和路径长度限制”章节。

如果选用小于 255 个字符的“长文件名上限”（"Long name max"）（最小值为 62），则 cppcryptfs 将限制文件名长度。即使选用 62 个字符，创建的文件名也是最多为 67 个字符。此选项适合搭配对文件名长度上限有要求的云服务。

您可以选用 AES256-GCM 或 AES256-SIV（RFC 5297）进行文件数据加密。默认为 AES256-GCM，推荐使用。GCM 在流式传输的读取和写入方面的速度约是 SIV 的两倍。实现 SIV 是为了支持反向模式。

注意：在 gocryptfs 文档中，SIV 模式称为 AES-512-SIV，这是此操作模式的专有名称。但是，它在 cppcryptfs 中称为 AES256-SIV，因为 512 位 SIV 密钥派生自 256 位主密钥（与 gocryptfs 的情况相同）。并且，cppcryptfs 的开发者不想在用户界面中将其称为 AES512-SIV，因为这可能导致用户误认为它比 AES256-GCM 更安全。

如果选中反向（Reverse），那么您将创建一个“反向模式”文件系统。详细信息见本文档中有关反向模式的章节。

如果您愿意，可以指定一个配置文件。配置文件中包含文件系统的设置，以及使用您的密码来加密的随机的 256 位 AES 主密钥。配置文件也可以保存在加密文件系统之外以提高安全性。

配置文件将在您单击“创建”按钮时被创建。它将在加密文件系统所在的根目录中创建为 gocryptfs.conf，除非您另有指定。除非您选择使用纯文本文件名，否则还将在那里创建一个 gocryptfs.diriv 文件。请务必备份这些文件，以防它们丢失或损坏。如果 gocryptfs.conf 发生问题，您将无法访问任何数据。gocryptfs.conf 在文件系统的整个生命周期内永远不会更改，除非您更改卷标（详见下文）。

如果您选择为卷指定一个卷标签，该标签将在 gocryptfs.conf 中加密存储。卷标最大长度为 32 个字符。

卷标是使用主密钥、128 位随机初始化向量和 8 个零字节的验证数据进行 AES256-GCM 加密。然后将其与初始向量一起进行 base64 编码并保存在 gocryptfs.conf 文件。

您可以在文件资源管理器中右击已挂载的盘符，选择“属性”，然后更改卷标。但是，这样做将导致 cppcryptfs 在卸载驱动器时重写 gocryptfs.conf。这确实会给您的 gocryptfs.conf 带来一些风险。同样，在某个地方备份 gocryptfs.conf 文件是个好主意。

如果底层文件系统（例如，通过 Samba 共享的 Linux 文件系统）不支持命名流，则可能需要“禁用命名流”选项。 cppcryptfs 通常会（在挂载时）自动检测底层文件系统是否支持命名流。但是，在某些配置中，底层文件系统报告它支持命名流，但实际上不支持。开发人员使用 Ubuntu 16.04 Samba 进行了测试，没有发现这个问题。添加此功能是为了帮助使用其他 Linux 版本时遇到此问题的用户。如果您在使用 Samba 时出现问题，并希望在创建文件系统后以追溯方式禁用命名流，请参阅 https://github.com/bailey27/cppcryptfs/issues/63。

然后转到“挂载”选项卡，选择一个盘符，并选择您的文件夹刚在其中创建了文件系统的文件夹。然后输入密码，并单击“挂载”按钮。

![Alt text](/screenshots/screenshot_mount.png?raw=true "挂载选项卡")

您也可以右击盘符列表，然后选择“添加挂载点”。这时您可以将一个空目录添加到盘符列表中。该空目录必须位于 NTFS 卷上，可以代替盘符作为挂载点使用。添加的挂载点将追加到原有列表的下方。您还可以右击已添加的挂载点然后选择将其从列表中删除。您手动添加的挂载点同样记录在 Windows 注册表中。

注意：虽然 A: 和 B: 可用作挂载点，但不建议使用它们，因为已知将加密文件系统挂载到它们会导致 Windows 更新出现问题。

您也可以右击已挂载的文件系统，然后卸载它或[查看其属性](/screenshots/screenshot_properties.png?raw=true)。

双击已挂载的卷为其打开一个文件资源管理器窗口。

如果在创建文件系统时指定了自定义路径的配置文件，则还必须在此处指定相应路径。

如果为配置文件指定了自定义路径，则还必须手动指定是否为“反向”文件系统。默认配置文件下，cppcryptfs 能自动检测文件系统应该以正向还是反向模式挂载。

注意：cppcryptfs 使用加密后文件系统的路径作为键值来记忆配置文件的自定义路径（如已设置）和其他设置（如反向模式和只读）。因此，在选择要挂载的路径时，务必验证检查显示的设置是否是您本次所需的设置。


挂载文件系统后，您将看到一个新的盘符，您可以像盘符一样使用，并且在里面存储敏感信息。数据经过加密并以文件形式保存在您指定的文件夹中。

如果选中“只读”，则该文件系统以只读（写保护）模式挂载。

有关 cppcryptfs 中密码保存的工作原理，详见下文“密码保存”章节。

如果您选中“自动挂载”（需要“保存密码”），则下次启动 cppcryptfs 时，该路径将在启动时被挂载到该挂载点。必须已保存该挂载的密码才能正常工作。

该路径将继续自动挂载，直至您取消“自动挂载”并且手动挂载它。

有关 gocryptfs 加密算法设计的技术细节，请访问 [gocryptfs 项目页面](https://github.com/rfjakob/gocryptfs)。

使用完毕后，转到“挂载”选项卡并选择相应驱动器号，然后单击“卸载”或“全部卸载”。这样将卸载驱动器号，并擦除内存中的加密密钥。

只要有未占用的驱动器号（盘符），您可以挂载尽可能多的 gocryptfs 文件系统。

密码和密钥使用 VirtualLock() 锁定在内存中。当不再需要时将使用 SecureZeroMemory() 擦除，然后解锁。如果您从不“休眠”计算机，更不必担心密码或密钥被写入硬盘。

关闭 cppcryptfs 窗口时将隐藏自身到系统托盘。如果要退出 cppcryptfs，使用挂载页面上的“退出”按钮，或者系统托盘中图标的右键菜单。

设置
---------
软件有一个设置选项卡。

![Alt text](/screenshots/screenshot_settings.png?raw=true "“设置”选项卡")  
*显示推荐设置*


更改“设置”选项卡上的值会影响随后挂载的所有文件系统。任何已挂载的文件系统不会受到影响。

目前设置被存储在 Windows 注册表，并且将在下次挂载文件系统时使用，包括从命令行进行的操作。

设置选项卡有以下设置：

**I/O 缓冲区大小（KB）**

此设置控制 cppcryptfs 每次对底层文件系统的读取/写入的大小。

cppcryptfs 实际上以加密块大小的倍数（即 4,128 字节）执行 I/O 操作。因此，当您指定 4KB 时，缓冲区大小实际上是 4,128 字节，而当您指定 1024KB 时，缓冲区大小实际上是 1,056,768 字节。

增加 I/O 缓冲区大小可能提升性能。

**缓存有效时间**

cppcryptfs 缓存有关其文件系统的信息。如果缓存中的项早于此有效时间，使用该项前将重新验证。

增加缓存有效时间或设置为无限将得到更好的性能。

但是，如果您正持续将 cppcryptfs 文件系统与另一台运行有 cppcryptfs 或 gocryptfs 的计算机上的同一文件系统副本同步，并且另一台计算机上修改了该文件系统，则较高的有效时间可能导致出错。

如果您没有同时在不同 cppcryptfs（或 gocryptfs）实例之间同步文件系统，则没有理由不将缓存时间设置为较高值或无限。

**多线程**

如果开启此选项，则每个文件系统有多个线程来处理请求。这可能提升性能。Dokany 会自动选择将使用的线程数。

如果禁用此选项，则每个文件系统将仅使用一个线程来处理请求。

**不区分大小写**

此选项仅在“正向”模式且使用了“加密文件名”时有效。采用“加密文件名”的“反向”模式的文件系统始终区分大小写，而“纯文本”文件名的文件系统始终不区分大小写。

通常，在选用了“文件名加密”时，cppcryptfs 要求使用与创建文件/目录时完全相同的大小写来打开文件或目录。

如果选中“忽略大小写”选项，则 cppcryptfs 在“正向”模式下将忽略文件和目录名的大小写，即使使用了文件名加密。这就是 Windows API 的正常运行方式。另外，性能会慢少许。

详情见“区分大小写”章节。

**启用挂载管理器（回收站）**

选择“默认”或“推荐”设置时，目前不会启用此设置。因此需要时必须手动启用它。该选项尚未经过充分测试。

此设置在加密卷上启用 Windows 挂载管理器（Windows Mount Manager）。启用挂载管理器将启用“回收站”功能。此设置仅在 cppcryptfs 以管理员身份运行时有效。如果您尝试在选中此设置的情况下挂载文件系统，但 cppcryptfs 未以管理员权限运行，cppcyrptfs 将显示一个警告对话框（对话框可以被禁用），并且不会启用挂载管理器。

此设置对“反向”文件系统或以只读方式挂载的文件系统没有影响。

注意：如果您正将被加密的文件系统文件与 Dropbox 同步，在启用挂载管理器（回收站）的情况下，Dropbox 会因缺乏权限而无法同步回收站中的文件。  
您应该以管理员权限运行 Dropbox，或者确定哪个被加密的文件夹名称是回收站的名称，然后使用 Dropbox 的选择性同步功能将其排除。如果您使用的是纯文本文件名，则回收站的文件夹名称是“$RECYCLE.BIN”。通过向 --list 命令行选项提供一个相对于根目录的未加密路径作为参数，可用于查询回收站的加密后名称。

例如


```

cppcryptfs --list=d:\


```

**启用密码保存**

启用此设置将允许保存密码。更多信息详见下文。

启用此设置后，挂载选项卡中的“保存密码”复选框将可用。

如果将“启用密码保存”设置从选中改为未选中，则 cppcryptfs 会询问是否应删除已保存的所有密码。

此设置在“默认”或“推荐”设置中不启用。

**不保存历史记录**

此设置可防止 cppcryptfs 在 Windows 注册表中保存设置（此页上描述的值除外）。例如，启用后将不再保存路径历史记录和密码，即使已启用“保存密码”。

选中此设置后，cppcryptfs 存储在 Windows 注册表中的所有值将被删除，但此页面上描述的设置（保存的密码）*除外*。在此设置生效期间，不能再保存任何新的密码。

要删除已保存的密码，您必须取消“保存密码”设置。

此设置在“默认”或“推荐”设置中不启用。

**删除 desktop.ini 文件**

此设置是因 https://github.com/bailey27/cppcryptfs/issues/62 而创建。据报告，Google 云端硬盘可能在被加密文件的源文件夹中的每个目录中里创建隐藏的 desktop.ini 文件。这些文件阻止了用户在未加密方向删除目录。如果文件系统挂载时启用了此设置，则 cppcryptfs 将在删除目录时自动删除未加密的 desktop.ini 文件。

此设置仅在“正向”模式且使用了“加密文件名”时有效。

此设置在“默认”或“推荐”设置中不启用。

**挂载时打开**

如果启用此设置，则在挂载加密卷时，将自动使用默认的 Windows 文件管理器（通常是“文件资源管理器”）打开该卷。

此设置在“默认”或“推荐”设置中不启用。

**加密内存中的密钥**

启用此设置后，cppcryptfs 会在不需要加密密钥（主密钥和任何派生密钥）时使用 Windows 数据保护 API（DPAPI）对其进行加密。密钥使用 DPAPI 进行加密，在需要时被解密，并在不需要时将非加密的副本清零。有关 DPAPI 的更多信息，见下文的“密码保存”章节。

此设置可降低恶意软件从 cppcyrptfs 的进程内存中读取未加密密钥的可能性。

此外，如果系统进入休眠状态，此设置可防止未加密的密钥最终出现在磁盘上的休眠文件中。

此设置是全新的，**其实现中的任何 bug 都可能导致数据丢失**。仅当您频繁备份加密的文件系统时，才建议使用此设置。

建议将“在内存中缓存密钥”（见下文）配合此设置使用。否则将对性能产生重大影响。

此设置在“默认”或“推荐”设置中不启用。

**在内存中缓存密钥**

如果“加密内存中的密钥”未启用，此设置不起作用。

如果启用此设置并同时启用“在内存中缓存加密密钥”，则 cppcryptfs 将在两次使用之间缓存未加密密钥长达一秒钟。

此设置将“加密内存中的密钥”的性能影响降低到基本为零。如果未启用此设置，则加密内存中的密钥会显著降低性能。

当系统即将进入待机或休眠模式时，cppcryptfs 会自动禁用缓存，因此当系统进入低功耗模式时，未加密的密钥不会出现在内存中。当系统唤醒时，缓存将自动重新启用。

此设置在“默认”或“推荐”设置中不启用。


**启用快速挂载**

在以前，cppcryptfs 始终等待 Dokany 回调以标示挂载操作成功还是失败。

Dokany 通常需要 5 秒钟才能完成回调。但是，文件系统看上去是立即挂载并可用。

“启用快速挂载”开启时，cppcryptfs 将等待 Dokany 的回调并定期轮询检查文件系统是否已挂载。如果 cppcryptfs 发现文件系统似乎已经挂载，cppcryptfs 将停止等待 Dokany 并假定挂载操作成功。如果禁用此设置，则 cppcryptfs 只会坚持等待 Dokany 的回调。

启用此设置后，在开发者的计算机上指示挂载操作成功只需约 31 毫秒，而不像以前那样需要 5 秒。

注意：当挂载点是空 NTFS 目录而不是驱动器号时，此设置不起作用。如果挂载点是目录，Dokany 会快速发出挂载成功信号，这种情况下轮询没有意义。

此设置默认启用。

**卸载时有使用则发出警告**

如果开启此设置，当用户尝试卸载文件系统、卸载所有文件系统或者退出程序时，假如挂载的文件系统上仍有任何打开的文件或目录，则 cppcryptfs 将通知用户并询问它是否应该继续卸载。

如果开启此设置，那么通过命令行卸载正在使用的文件系统时需附加 --force 选项。

此设置在“默认”或“推荐”设置中不启用。

**拒绝其他会话**

如果启用此设置，则加密卷只能在启动 cppcryptfs 实例来挂载加密卷的会话中访问。挂载所用的盘符仍对其他会话可见，但其他会话将无法访问。

这只是在调用 CreateFile API 时进行检查，创建新文件/目录或者打开现有文件/目录时会调用该 API。这似乎已经足够。

测试此功能的开发者相信，该设置应足以避免挂载的卷被共享同一台计算机并登录到其他会话的另一名普通用户访问。但是，还不确定有决心和专业知识的攻击者是否不能找到规避此保护的方法。

有关细节详见下文的“拒绝服务”说明。

此设置在“默认”或“推荐”设置中不启用。

**拒绝服务（Services）**

如果启用此设置，则“会话 0”中运行的 Windows 服务将不能访问加密卷。

使用系统帐户运行，或者用户创建并拥有“作为操作系统的一部分（Act as part of the operating system）”用户权限的 Windows 服务，可以任意创建访问令牌和设置任意会话 ID。因此，此保护不能绝对避免，但应该能防止正常情况下的 Windows 服务访问已挂载的文件系统。

此设置在“默认”或“推荐”设置中不启用。


**默认值和推荐值**

这些按钮用来将所有设置还原为默认设置或推荐设置。

目前，默认设置和推荐设置相同。

**重置警告**

点击“重置警告”按钮将重新开启以前选择过“不再显示此消息”而禁用的所有警告对话框。


更多设置
---------
这是另一个设置选项卡。

![Alt text](/screenshots/screenshot_more_settings.png?raw=true "设置选项卡")  
*显示了推荐设置*

“更多设置”选项卡有以下额外设置：

**启用写入后刷新**

一位用户报告说，在将大量数据复制到使用 exFAT 文件系统格式化的外部驱动器时遇到了超时情况。

这个问题似乎只出现在 exFAT。

解决方法是启用写入后刷新（flush）。启用此设置后，cppcryptfs 每次写入数据时将强制 Windows 立即将数据写入磁盘。

此选项会显著降低写入性能。对于复制大文件，可能相差一半左右。而对于大量小文件，情况更糟。

此设置在任意条件符合时开启，因此如果要始终启用，可以同时选中“NTFS”和“非 NTFS”选项。


保存的密码
------

如果在设置选项卡中启用了“启用密码保存”设置，则挂载选项卡上的“保存密码”复选框将可用。

cppcryptfs 保存密码时使用 Windows 数据保护 API（DPAPI）来加密密码。Windows DPAPI 的介绍详见这里。

https://msdn.microsoft.com/en-us/library/ms995355.aspx

使用 Windows DPAPI 加密的数据的安全性，取决于登录该 Windows 所用的密码的强度和安全性。

保存的密码与加密文件系统的根目录路径相关联。

此外，“保存的密码”设置本身与路径相关联。

要保存一个密码，需确保在挂载文件系统时选中“保存密码”选项。

密码将使用 DPAPI 加密并保存在 Windows 注册表中。

若要避免挂载文件系统时输入密码，请选中“保存密码”选项，然后从路径历史记录中选择路径，此时会在密码框中填写该对应的密码（如果曾经保存），密码显示为点。如果您在路径框中输入路径，然后点击“挂载”而不输入密码，也将查找并使用已保存的该路径的密码。

命令行选项 -P 可用作从命令行使用已保存的密码挂载文件系统。


反向模式
------
在反向模式下，用于该文件系统的源文件（即根）目录由未加密的文件构成。挂载该目录后，cppcryptfs 的驱动器号里面将动态提供这些文件的已加密视角。

反向模式还提供了配置文件（名为 gocryptfs.conf），如果使用了加密文件名功能，则每个目录中也都有一个 gocryptfs.diriv 文件。如果长文件名与加密文件名一起使用，则还会呈现特殊的长文件名文件。

反向模式文件系统始终以只读方式挂载。

创建一个反向模式文件系统时，该文件系统的根目录不必为空（不同于创建一般的正向模式文件系统）。cppcryptfs 将在文件系统的根目录中创建一个名为 .gocryptfs.reverse.conf 的隐藏配置文件，不同于一般的正向模式下的非隐藏的 gocryptfs.conf 文件。

当您挂载文件系统时，cppcryptfs 首先会查找 .gocryptfs.reverse.conf，如果找到则将以反向模式挂载该文件系统。如果找不到 .gocryptfs.reverse.conf，那么将尝试打开 gocryptfs.conf，成功则会以正常的正向模式挂载该文件系统。

如果指定了自定义路径的配置文件，则必须选中“reverse”以反向模式挂载文件系统。

如果您挂载一个反向文件系统，然后将整个目录树复制到其他的位置，之后则可以将该副本（包含加密的文件、正常模式配置文件和其他支持文件）作为正向（正常）文件系统挂载。

当您想要加密备份未加密文件组成的整个目录树时，反向模式非常有用。

反向模式对文件数据使用确定性 AES256-SIV 加密模式（实际上是 AES512-SIV，但 512 位 SIV 密钥派生自 256 位主密钥），并且它还执行确定性的文件名加密。

注意：在正向模式下挂载使用 AES256-SIV 的文件系统时，进行的任何新加密都是非确定性的（与 gocryptfs 保持一致）。

由于反向模式下的加密是确定性的，因此可以使用 rsync 等实用工具备份加密的文件，工具将仅复制有变更的文件。如果您的备份工具在处理未加密数据时支持增量同步（如 rsync 所做的那样），那么在反向模式下同步加密的数据时也只需要已变更的部分。但是，如果有数据被插入到文件中，则已加密文件的数据中将出现从插入数据点开始的级联更改（准确说是从那个加密数据块开始），从那里开始的数据需要被再次复制。

可以在正向模式下挂载已挂载的反向文件系统。此时正向文件系统也将是只读的。这主要用于测试。

命令行选项
----
cppcryptfs 能接受一些挂载和卸载文件系统的命令行选项。但截至目前，文件系统的创建只能通过图形界面（GUI）完成。

同时只能有一个正在运行的 cppcryptfs 主实例。如果没有其他的 cppcryptfs 实例正在运行，则 cppcryptfs 将处理任何命令行参数，然后持续运行。如果已有另一个 cppcryptfs 实例在运行，则 cppcryptfs 会将其命令行参数发送到已在运行的主实例。如果运行来自控制台窗口，程序会将处理命令行后的输出内容印到控制台。如果不是从控制台运行，程序将在消息框中显示输出。

项目还有一个配套程序 cppcryptfsctl，可用于将命令发送到已在运行的 cppcryptfs。cppcryptfsctl 是一个控制台程序。
使用它的优点是它设置了 ERRORLEVEL，因此可以在批处理脚本中对其进行测试。此外，也可以将 cppcryptfsctl 的输出重定向到文件，或者将其管道传输到另一个程序，例如 findstr 的 grep。cppcryptfs 未设置 ERRORLEVEL，并且无法重定向其输出。

cppcryptfsctl 执行成功时将 ERRORLEVEL 设为 0；发生错误则设为 1；如果无法连接（没有正在运行的 cppcryptfs）则设为 2。

通过命令行传递密码并不安全。cppcryptfs 会锁定并清零命令行的内部副本，但并不能清零存储在 Windows PEB（进程环境块）中的命令行。此外，如果 cppcyrptfs 已在运行，从命令行调用 cppcryptfs（或 cppcryptfsctl）将导致它将命令行传递给已运行的实例。它尝试以足够安全的方式执行此操作。它使用本地的 Windows 命名管道与正在运行的实例通信。如果管道中任意一端运行的程序已被签名，则程序还会验证管道另一端的程序是否是已签名的可执行文件运行，并且两个签名上的通用名是否相同。但是，目前尚不清楚 Windows 可能会将 cppcryptfs 控制的命令行复制多少次。因此，如果使用了分页文件（页面文件），则通过命令行传递的密码可能会最终出现在分页文件中。

命名管道的名称使用启动 cppcryptfs 的用户的用户名和域来点缀。因此，cppcryptfs/cppcryptfsctl 只能与由同一用户启动的 cppcryptfs 实例通信。

```

用法：cppcryptfs/cppcryptfsctl [选项]

挂载：
  -m， --mount=PATH 挂载位于指定路径的文件系统
  -d， --drive=D 挂载到驱动器号 D 或指定的空目录
  -p， --password=PASS 使用密码 PASS
  -P， --saved-password 使用保存的密码
  -r， --readonly              挂载为只读
  -c， --config=PATH 初始化/挂载使用指定路径的配置文件
  -s， --reverse               初始化/挂载反向模式的文件系统（初始化隐含 siv）
  --deny-other-sessions [1|0]       启用/禁用拒绝其他会话的访问
  --deny-services [1|0] 启用/禁用拒绝服务（services）的访问

卸载：
  -u， --unmount=D 卸载驱动器号 D 或指定的目录
  -u， --unmount=all 卸载所有的驱动器
  -f， --force 强制卸载使用中的挂载

其他：
  -t， --tray                 隐藏在系统托盘中
  -x， --exit 如果未挂载驱动器则退出
  -l， --list  列出可用的驱动器号（盘符）和已挂载的文件系统
  -ld:\p， --list=d:\p 列出明文和加密的文件名
  -C， --csv 文件列表以逗号分隔呈现
  -D， --dir 文件列表中目录先行且尾缀 \
  -Mpath, --transform=path   转换完整路径（加密或解密）
  -i， --info=D 显示已挂载文件系统的相关信息
  -v， --version 列出版本号（cppcryptfsctl 的版本需使用 --init -v）
  -h， --help 显示此帮助消息

初始化（仅限 cppcryptfsctl）：
  -I， --init=PATH 在 PATH 初始化加密文件系统
  -V， --volumename=NAME 指定文件系统的卷名（卷标）
  -T， --plaintext             使用纯文本文件名（默认则是 AES256-EME）
  -S， --siv 数据转换使用 AES256-SIV（默认则是 GCM）
  -L、--longnames [1|0] 启用/禁用 LFN（长文件名）。默认为启用（1）
  -b， --streams [1|0] 启用/禁用（命名）流。默认为启用 （1）
  --longnamemax N 将文件名限制为最多 N 个字符

找回/维护（仅限 cppcryptfsctl）：
  --changepassword=PATH 更改保护主密钥的密码
  --printmasterkey=PATH 以人类可读的格式列出主密钥
  --recover=PATH 要求用户输入找回用的主密钥和新的密码

```

只有 cppcryptfsctl 可以从命令行（--init）创建一个文件系统。如果要使用 cppcryptfs 创建文件系统，必须使用图形界面（GUI）。

创建/初始化文件系统时，如果以交互方式运行，cppcryptfsctl 将提示输入密码并重复密码而不进行回显。如果其标准输入被重定向，它将从标准输入读取密码而不提示用户输入。

如要获取 cppcryptfsctl 的版本，必须指定 initialize 和 -v。例如 cppcryptfsctl -I -v，否则它将尝试获取并列出正在运行的 cppcryptfs 实例的版本。

部分选项在初始化和挂载（--config 和 --reverse）环节中是通用的。

注意：使用选项的简短版本时，不应在选项与其参数之间使用等号。使用选项的长版本时，等号是可选的。例如，下列有效

此外，如果打算将卷挂载到一个驱动器号，不应该在驱动器选项的参数中包含 \\ 字符。例如，如果要挂载到驱动器“r:”，使用“-dr:”而不是“-dr:\\”。


```
cppcryptfs -m c:\tmp\test -d k -p XYZ
cppcryptfs --mount=c:\tmp\test --drive=k --password=XYZ
cppcryptfs --mount c:\tmp\test --drive k --password XYZ

```

--list 选项有一个可选参数。如果没有提供参数，则它列出驱动器号，并显示已挂载的文件系统的加密版文件系统根目录所在路径。

list 命令还将完整路径作为可选参数。路径应为文件或目录（包括驱动器号）的未加密名称。如果参数是一个文件，则 cppcryptfs 将在左侧列出未加密的文件路径，在右侧列出加密后的路径。如果参数是一个目录，则 cppcryptfs 将在左侧列出若干文件的未加密名称，在右侧列出加密后名称。

由于可选参数的处理方式，如果使用 list 选项的缩写形式（-l），则必须将路径放在 -l 之后且不带空格间隔。如果使用长格式参数（--list），则必须使用"="符号。例如

```
cppcryptfs -lk:\foo

cppcryptfs --list=k:\foo

```

同时只能运行一个 cppcryptfs 实例。

当调用 cppcryptfs 时，它会检查是否有另一个实例正在运行。如果有，那么如果没有命令行选项，则 cppcryptfs 的第二个实例将直接退出。如果没有其他运行中的实例，则它将处理命令行选项（如果有）并继续运行，除非指定了 --exit 参数并且没有已挂载的驱动器。

因此，如果您打算在批处理文件中使用 cppcryptfs 或 cppcryptfsctl，需要先在后台中启动一份实例。然后，您还应该在前台执行其他操作，以等待启动完成。

如果在后台启动了“cppcryptfs --tray”，假如已有一个正在运行的实例，则该实例将被告知将其自身隐藏到系统托盘中。如果没有实例在运行，那么您将启动一个隐藏在系统托盘中并保持在后台运行的 cppcryptfs。

下面是一个使用 cppcryptfs 的 Windows cmd 批处理文件示例。


```
@rem ====================================================
@rem 在后台运行 cppcryptfs 并等待片刻
@rem ====================================================

start cppcryptfs.exe --tray
timeout /t 1 >nul

@rem ====================================================
@rem 挂载驱动器 U:
@rem ====================================================

cppcryptfs.exe --mount=d:\TestCppCryptFS --drive=u --password=PASSWORD --tray  --exit

@rem ====================================================
@rem 挂载驱动器 V:
@rem ====================================================

cppcryptfs.exe --mount=d:\TestCppCryptFS2 --drive=v --password=PASSWORD --tray  --exit

@rem ====================================================
@rem 在挂载的驱动器上运行命令
@rem ====================================================

copy  C:\test.txt U:\test.txt
copy  C:\test.txt V:\test.txt
```

下面是一个 cygwin bash scrypt 示例。注意，在 bash 中需要为安装路径使用双反斜杠。


```

#！/bin/bash
# 在后台启动 cppcryptfs 并隐藏在系统托盘中
/cygdrive/c/bin/cppcryptfs -t &
# 给它时间初始化
sleep 1
# 挂载文件系统并等待挂载操作完成
/cygdrive/c/bin/cppcryptfs --mount c：\\tmp\\test -d k -p XYZ
# 做备份操作
rsync .....
# 卸载所有驱动器并退出
/cygdrive/c/bin/cppcryptfs -you all -x

```

更改密码
------
cppcryptfsctl 可以更改保护配置文件中主密钥所用的密码。配置文件通常是 gocryptfs.conf 或 .gocryptfs.reverse.conf。

此功能主要适用于想换一个密码的人。这不是应对密码泄露的良好解决方案。

更改密码只是更改了挂载文件系统所需的密码。它不会更改加密数据所用的加密密钥。用来加密数据的密钥存储在配置文件中，通过从密码派生一个密钥来保护。因而，密码只是用来解密实际要用的加密密钥。

因此，如果有人持有您原有的密码和配置文件副本，那么即便您更改了密码，他们仍然可以解密您原有和新增的所有数据。

如果您认为您的密码已被泄露，并且认为有人可能已经拥有您的配置文件，那么最好的办法是新建一个使用新密码的文件系统，挂载它，并挂载旧文件系统，将数据从旧的未加密视图复制到新的未加密视图。

密码丢失后的恢复
-----------
如果您之前打印或保存了未加密的主密钥，才可能进行密码丢失后的数据恢复。

如果您运行：

cppcryptfsctl --printmasterkey PATH（加密的文件系统目录或配置文件的路径）

它将以人类可读的形式印出未加密的主密钥。例如，您可以打印它并将其保存到上锁的抽屉中。

如果您忘记了密码，可以运行

cppcryptfsctl --recover 路径

它将提示您输入主密钥，然后提示您输入新的密码和确认新密码。

此操作将覆盖目标配置文件中的主密钥。执行此操作之前，它会备份配置文件（用原名称加.bak后缀）。如果 .bak 文件已存在，将要求您删除或移走现有的 .bak 文件。


配置文件丢失或损坏后的恢复
-----------
此操作同样要求您持有未加密的主密钥。

cppcryptfsctl --printmasterkey PATH（指定加密文件系统所在目录或配置文件的路径）

这将以人类可读的形式列出未加密的主密钥。如果执行此操作并妥善保存该密钥，在配置文件丢失或损坏时则可以用它来恢复原状。

操作流程如下（假设您之前已列出并妥善备份对应的主密钥）：

1. 您将需要创建一个新的文件系统，使用与要恢复的文件系统完全相同的参数（例如数据加密方法、文件名加密方法、长文件名等选项。路径除外）。

您使用的密码在这里不重要。

2. 使用 cppcryptfsctl --recover 路径 将旧文件系统中的主密钥放到该配置文件中。

这会将该配置文件中的主密钥替换为您输入的主密钥。它将使用您选择的新密码进行加密。

3. 尝试指定新的配置文件的路径来挂载旧的文件系统，看是否生效（测试确保可以从中读取数据）。

4. 如果一切正常，那么您可以考虑将恢复的配置文件放到加密文件系统的根目录中。

此处唯一的问题是，如果操作的这个文件系统是使用 gocryptfs 或 cppcryptfs 版本 1.3（2017年4月~5月发布）或更早版本的工具来创建，那么会有 HKDF 和 Raw64 的问题。这些现在是默认值，并且是创建配置文件所必需的。

因此，如果您正在恢复是旧的文件系统，并且它不起作用，请尝试编辑您创建的用于恢复的配置文件，并移除下列行

```
        "HKDF",
        "Raw64",
```

然后看看这是否有效。


文件名和路径长度限制
------

如果创建文件系统时指定了“长文件名”（默认值），或者使用了纯文本文件名，并且基础文件系统足够现代（例如 NTFS/exFAT/FAT32），则一个文件或目录名称最长为 255 个字符，而完整路径最长约为 32,000 个字符。

如果未指定“长文件名”并且未使用纯文本文件名，则文件或目录名称最长为为 160 个字符。但完整路径的限制仍约为 32,000 个字符（假设 NTFS/exFAT/FAT32）。

文件名被加密时会从 UNICODE-16 转换为 UTF-8，根据语言的不同，有可能导致字符数增加。加密过程中还会向其填充最多 16 个字节。然后会进行 base64 编码，这通常导致长度增加 33%。因此，加密后的文件名可能变长不少。

另外，加密的文件系统所在目录的路径（在调用时）必将作为加密后文件名的路径前缀。

陈旧的文件系统（如 FAT16）会将总路径长度限制为 259 个字符。

因此，强烈建议尽可能使用 NTFS、exFAT 或 FAT32 等现代文件系统。

许多 Windows 程序（包括 Windows 自带的文件资源管理器）在遇到路径长度超过传统的 259 个字符限制时都会出现问题，无论使用哪种基础文件系统。如果使用加密文件名，则当移动加密的文件系统的根目录时，可能需要使用能处理长文件路径的第三方文件管理器。最好是先复制它，然后再删除旧的文件，而不是直接移动它，以防文件管理器在移动途中报错。


区分大小写
-----
Windows API 不区分文件名的大小写，但 Windows 文件系统（NTFS 和 FAT32）保留文件名的大小写。

在 Windows 中，如果将文件创建为 "Foo.txt"，然后尝试用 "foo.txt" 打开它，不会出现问题。

大多数（但并非全部）软件使用与创建文件时相同的大小写打开文件。

如果选用“加密的文件名”，cppcryptfs 原本始终区分大小写，因为 gocryptfs 的设计如此。

因而，如果使用了加密文件名功能，将文件创建为"Foo.txt"后如果尝试打开"foo.txt"，会出现找不到该文件错误。

cppcryptfs 现在已有“忽略大小写”设置，搭配它时即使使用了“加密文件名”，也会忽略文件名大小写的差异，不过此选项仅在正向（正常）模式下有效。

在反向模式下，如果选用加密文件名，则文件名始终区分大小写，而不考虑“忽略大小写”设置。这是一项必要的预防措施，因为如果加密后文件的文件名大小写被备份软件等系统更改，随后以正向模式挂载该文件系统的副本时文件名将无法正确解密。

如果使用纯文本文件名，则无论大小写设置如何，在正向和反向模式下，文件名始终不区分大小写。


性能
------
下方是一些基准测试结果。测试是在 Windows 10 64位系统下使用 cygwin 实用程序进行的，该实用程序运行在一个装有 Crucial M500 240GB SSD、Intel i5-4200U CPU 的系统上。使用 cppcryptfs，AES256-GCM 来加密文件数据，使用加密的文件名和长文件名。

Windows Defender 实时扫描在测试期间被禁用，因为它严重拖慢了 cygwin tar 的速度。在启用实时扫描的原生 NTFS 上提取 linux-3.0.tar.gz 需要2分43.6秒。

cppcryptfs 的性能与 Dokany 的镜像示例程序（不加密）大致相同。该 SSD 的流写入性能额定值为每秒 250 MB。

```
                                cppcryptfs      原生 NTFS     Dokany 镜像

数据流写入                 168 MB/s        224 MB/s        181 MB/s
解压 linux-3.0.tar.gz        1m36.412s       0m21.291s       1m34.125s	
ls -lR linux-3.0                1m1.979s        0m2.983s        1m11.618s
删除 linux-3.0                1m28.749s       0m10.144s       1m24.677s

```

上述基准测试是在很久以前进行的。gocryptfs 的创建者最近发布了类似的基准测试，比较了 cppcryptfs 与 Windows 上的其他加密文件系统。

https://nuetzlich.net/gocryptfs/comparison/#performance-on-windows

有些结果更快，但大多数结果比上述基准测试结果慢。
这可能解释为 Windows Defender 实时保护在测试期间未被禁用的的影响。
测试期间的所有加密文件系统似乎都受到了同样的影响。

与 gocryptfs 的兼容性
------

cppcryptfs 可以挂载 gocryptfs v0.7 及更高版本创建的所有文件系统。同样，由 cppcryptfs 创建的采用“长文件名 = 关”的文件系统也可以由 gocryptfs v0.7 及更高版本挂载。而“长文件名 = 开”的文件系统可以用 gocryptfs v0.9 及更高版本挂载。

gocryptfs [兼容性矩阵](https://github.com/rfjakob/gocryptfs/wiki/Compatibility) 提供了更多细节。cppcryptfs *需要* DirIV、EMENames（如果使用加密文件名而不是纯文本文件名）和 GCMIV128 功能标志。它*支持*长文件名，并且可以创建长文件名=开启或关闭状态的文件系统。

注意：cppcryptfs 现在保持与 gocryptfs 等价的版本号来标示与 gocryptfs 的兼容性。cppcryptfs 现在是 1.4 版，所以应该能挂载使用 gocryptfs 1.4 创建的所有文件系统。


